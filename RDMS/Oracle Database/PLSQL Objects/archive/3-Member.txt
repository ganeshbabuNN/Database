---MEMBER Procedures
-------------------
a member functions is allows to operate on the instance of the type, an instance of type that are type contains data. the type is a definiations and instance of type are where we have called three types of that single instance

emp_obj4.sql

CREATE OR REPLACE TYPE emp_obj
AS OBJECT 
(
  last_name VARCHAR2(25),
  first_name VARCHAR2(20),
  email VARCHAR2(25),
  phone_number VARCHAR2(20),
  hire_date DATE,
  salary NUMBER(8,2),
  
  MEMBER PROCEDURE print, --- included the print procedures
  
  CONSTRUCTOR FUNCTION emp_obj
    RETURN SELF AS RESULT,
    
  CONSTRUCTOR FUNCTION emp_obj(
    email IN VARCHAR2 )      
    RETURN SELF AS RESULT
)  
NOT FINAL 
/

create or replace
TYPE BODY emp_obj
AS 

  MEMBER PROCEDURE print    --- implemented the print procedure just for printing the last name...etc
  IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('Last Name: ' || SELF.last_name);
    DBMS_OUTPUT.PUT_LINE('Email: ' || SELF.email);
    DBMS_OUTPUT.PUT_LINE('Salary: ' || TO_CHAR(SELF.salary));
  END;
    
  CONSTRUCTOR FUNCTION emp_obj
    RETURN SELF AS RESULT
  IS
  BEGIN
    SELF.salary := 0;
    RETURN;
  END;  
  
  CONSTRUCTOR FUNCTION emp_obj(
    email IN VARCHAR2 )      
    RETURN SELF AS RESULT
  IS
  BEGIN
    SELF.email := email;
    
    RETURN;
  END;
END;
/

---now call the emp_obj where actually its called the instance of the object like how we are calling package with the procedures and functions.
here the print is the procedures of the instance of member procedures 'print'
call_emp_obj4.sql
DECLARE  
  v_emp_obj emp_obj;
BEGIN

  v_emp_obj := emp_obj();

  v_emp_obj.print;
  
  v_emp_obj := emp_obj(
    email => 'ganesh@gmail.com' );
  
  v_emp_obj.print;
  
  v_emp_obj := emp_obj(
    last_name => 'ga',
    first_name => 'dd',
    email => 'ganesh@gmail.com',
    phone_number => '3322',
    hire_date => sysdate,
    salary => 333);

  v_emp_obj.print;
    
END;  
/

---Even you call the object type with the instance name with 'v_emp_obj.last_name' ...etc
DECLARE  
  v_emp_obj emp_obj;
BEGIN

  v_emp_obj := emp_obj();
  DBMS_OUTPUT.PUT_LINE('Last Name: ' || v_emp_obj.last_name);
  DBMS_OUTPUT.PUT_LINE('Email: ' || v_emp_obj.email);
  DBMS_OUTPUT.PUT_LINE('Salary: ' || TO_CHAR(v_emp_obj.salary));
    
END;  
/

MEMBER Functions
-----------------
which like a return the value which is passed.

emp_obj5.sql
CREATE OR REPLACE TYPE emp_obj
AS OBJECT 
(
  last_name VARCHAR2(25),
  first_name VARCHAR2(20),
  email VARCHAR2(25),
  phone_number VARCHAR2(20),
  hire_date DATE,
  salary NUMBER(8,2),
  
  MEMBER PROCEDURE print,
  
  MEMBER FUNCTION bonus(
    p_percent IN NUMBER )
    RETURN NUMBER,
  
  CONSTRUCTOR FUNCTION emp_obj
    RETURN SELF AS RESULT,
    
  CONSTRUCTOR FUNCTION emp_obj(
    email IN VARCHAR2 )      
    RETURN SELF AS RESULT
)  
NOT FINAL 
/

create or replace
TYPE BODY emp_obj
AS 

  MEMBER FUNCTION bonus(
    p_percent IN NUMBER )
    RETURN NUMBER
  AS
  BEGIN
    RETURN SELF.salary * p_percent;
  END;
  
  MEMBER PROCEDURE print
  IS
  BEGIN
    DBMS_OUTPUT.PUT_LINE('Last Name: ' || SELF.last_name);
    DBMS_OUTPUT.PUT_LINE('Email: ' || SELF.email);
    DBMS_OUTPUT.PUT_LINE('Salary: ' || TO_CHAR(SELF.salary));
  END;
    
  CONSTRUCTOR FUNCTION emp_obj
    RETURN SELF AS RESULT
  IS
  BEGIN
    SELF.salary := 0;
    RETURN;
  END;  
  
  CONSTRUCTOR FUNCTION emp_obj(
    email IN VARCHAR2 )      
    RETURN SELF AS RESULT
  IS
  BEGIN
    SELF.email := email;
    
    RETURN;
  END;
END;
/

---and now call the object with those member functions.
call_emp_obj5.sql
DECLARE  
  v_emp_obj emp_obj;
BEGIN
  
  v_emp_obj := emp_obj(
    last_name => 'ganesh',
    first_name => 'baba',
    email => 'gbag@gmail.com',
    phone_number => '13423423',
    hire_date => sysdate,
    salary => 3344);

  v_emp_obj.print;
    
  dbms_output.put_line(
    v_emp_obj.bonus(0.10));
    
END;  
/

--remember the program unit in the type is directly represent what the type represent, something like this is an employee can you act on employees, think about the type are related to traisent operations where packages is used for persitance operations. where think package is still used as a employee API