UTIL PACKAGES
=============

-we use dbms_output for displaying the output in the console , you can do the same in reading the file and writing into the file to the operating systems.
-there are some steps to be followed for getting the output

steps to create the directory and access
----------------------------------------
Create a directory in the operating system

mkdir \emp_demo

Once you have the actual directory on the drive, create a directory at the database level. 

You may need to access the database as a DBA or have the permission create directory assigned to you account.

If you are using the HR account, you can log in as sysdba and 

GRANT create any directory TO hr;

or create the directory and grant read write access to HR. 


As HR, run this to create the directory.

CREATE OR REPLACE DIRECTORY file_dir AS 'C:\emp_demo'; 


Basic struture for File hanlder
------------------------------
-- fh is like a pointer based like a C pointer or an ID of an File. this is used to handle multiple file so that we can use. file handle is identified by the file type called UTL_FILE.file_type package 
declare
   fh UTL_FILE.file_type;
begin
   null;
end;


Basic Write mode operations
--------------------------
declare
  fh UTL_FILE.file_type;
begin
  fh := utl_file.fopen(
   location => 'FILE_DIR',
   filename => 'first_file.txt',
   open_mode => 'w');
  utl_file.fclose(fh);
end;
---check the directory where the file is listed. it will overide if the exists

Reading a file file does not exists
------------------------------------
--check if it works, or else change it to the file which we have created and written.
declare
  fh UTL_FILE.file_type;
begin
  fh := utl_file.fopen(
   location => 'FILE_DIR',
   filename => 'first_file2.txt',
   open_mode => 'r');
  utl_file.fclose(fh);
end;

Write to a File
----------------
--write the file and check the 
open_file_append_lines.sql

DECLARE
  fh UTL_FILE.file_type;
BEGIN
  fh := utl_file.fopen(
       location => 'FILE_DIR', 
       filename => 'first_file.txt',
       open_mode => 'a');
       
  FOR i IN 1..5
  LOOP
    utl_file.put_line(fh,
        'Hello. This is line ' ||
        to_char(i) );
  END LOOP;
  
  utl_file.fclose(fh);
  
END;
/

open_file_append_nolinefeed.sql
DECLARE
  fh UTL_FILE.file_type;
BEGIN
  fh := utl_file.fopen(
       location => 'FILE_DIR', 
       filename => 'first_file.txt',
       open_mode => 'a');
       
  FOR i IN 1..5
  LOOP
    utl_file.put(fh,
        'Hello. This is line ' ||
        to_char(i) );
  END LOOP;
  
  utl_file.fclose(fh);
  
END;
/

Reading a file from buffer
---------------------------
---reading from the buffers
read_the_file.sql

DECLARE
  fh UTL_FILE.file_type;
  v_buffer VARCHAR2(1000);
BEGIN
  fh := utl_file.fopen(
       location => 'FILE_DIR', 
       filename => 'first_file.txt',
       open_mode => 'r');
       
  FOR i IN 1..6
  LOOP
    utl_file.get_line(fh, v_buffer );
        
    dbms_output.put_line(v_buffer);    
  END LOOP;
  
  utl_file.fclose(fh);
  
END;
/

HANDLING EXCEPTION IF NO_DATA_FOUND
----------------------------------
reading_file_to_eof.sql
DECLARE
  fh UTL_FILE.file_type;
  v_buffer VARCHAR2(1000);
BEGIN
  fh := utl_file.fopen(
       location => 'FILE_DIR', 
       filename => 'first_file.txt',
       open_mode => 'r');
  
  BEGIN     
    LOOP
      utl_file.get_line(fh, v_buffer );
        
      dbms_output.put_line(v_buffer);    
    END LOOP;
  EXCEPTION
  WHEN NO_DATA_FOUND
  THEN
    NULL;
  END;

  utl_file.fclose(fh);
  
END;
/

--Assigning copying the file and rename the file.
--read and write the binary file




