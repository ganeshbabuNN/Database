CURSOR
=======

-Cursor is a select statement or kind of statement stuck into a varaibles. here you open the cursor,fetch a rows and then close the cursors
--- in this below example, I declared p_employee_id a variable in a type employee_id which is a parameter, where i can reuse the varaible in the select statements and then declared a local record of the cursor type as Record type.
1) open the cursor and pass the Id i,e 101
2) and fetch that row that i opened and fetch into the local record or else you can fetch into individual column like featch c1 into first_name, last_name,email...etc instead of that you can you local record which is declared as Record type
3) closed the cursor
 
cursor_open_fetch_close.sql

DECLARE
  CURSOR c1( p_employee_id IN employees.employee_id%TYPE ) IS
    SELECT first_name, last_name, email, phone_number, hire_date
      FROM employees
      WHERE employee_id = p_employee_id;
      
  v_local_record C1%ROWTYPE;
BEGIN

    OPEN c1(101);
	
	FETCH c1 INTO v_local_record;
	
	CLOSE c1;
	
	logit(v_local_record.email, 'D');
	
END;
/

---let try it again, where the employee_id does not exists, you may observer cursor will not raise any exception ..basically it hides exception if there is not record

DECLARE
  CURSOR c1( p_employee_id IN employees.employee_id%TYPE ) IS
    SELECT first_name, last_name, email, phone_number, hire_date
      FROM employees
      WHERE employee_id = p_employee_id;
      
  v_local_record C1%ROWTYPE;
BEGIN

    OPEN c1(11111);	
    FETCH c1 INTO v_local_record;	
    CLOSE c1;	
    logit(v_local_record.email, 'D');	
END;
/

--- if you want to catch that exception or hiding exception which is cursor branch the statement and proceed
%NOTFOUND is a cursor attributes. there are more attributes like FOUND, ROWCOUNT

lik
cursor__attributes.sql
DECLARE
  CURSOR c1( p_employee_id IN employees.employee_id%TYPE ) IS
    SELECT first_name, last_name, email, phone_number, hire_date
      FROM employees
      WHERE employee_id = p_employee_id;
      
  v_local_record C1%ROWTYPE;
BEGIN
    OPEN c1(11111);	
    FETCH c1 INTO v_local_record;	
    IF c1%NOTFOUND
    THEN 
    logit('no record found' ,'D' );
    end if;
    CLOSE c1;	
    logit(v_local_record.email, 'D');	
END;
/


%ROWCOUNT WITH LOOPS

======================


cursor_loop.sql

DECLARE
  CURSOR c1( p_cnt IN NUMBER ) IS
    SELECT first_name, last_name, email, phone_number, hire_date
      FROM employees
      WHERE rownum < p_cnt;      
  v_local_record C1%ROWTYPE;
BEGIN
  OPEN c1(10);	
  LOOP
    FETCH c1 INTO v_local_record;	
    EXIT WHEN c1%NOTFOUND;    
    logit(v_local_record.email, 'D');
  END LOOP;  
  CLOSE c1;
END;
/

--restrict the rowcount during iterations
DECLARE
  CURSOR c1( p_cnt IN NUMBER ) IS
    SELECT first_name, last_name, email, phone_number, hire_date
      FROM employees
      WHERE rownum < p_cnt;      
  v_local_record C1%ROWTYPE;
BEGIN
  OPEN c1(10);	
  LOOP
    FETCH c1 INTO v_local_record;
      logit(v_local_record.email, 'D');	
    EXIT WHEN c1%ROWCOUNT = 4;      
  END LOOP;  
  CLOSE c1;
END;
/


CURSOR FOR LOOP
===============
--if you want to fetch multiple rows then use the cursor for loop
--- here some difference the v_local_record will be created by the for loop based on the record type you selected

cursor_for_loop.sql
DECLARE
  CURSOR c1( p_cnt IN NUMBER ) IS
    SELECT first_name, last_name, email, phone_number, hire_date
      FROM employees
      WHERE rownum < p_cnt;
BEGIN

  FOR v_local_record IN c1(10)
  LOOP

    logit(v_local_record.email, 'D');

  END LOOP;
  
END;
/

---Still we can clean the above code, the key message over here to see how tightly SQL is intregrated into PLSQL, it makes the life easier

cursor_for_clean.sql
BEGIN

  FOR v_local_record IN (
    SELECT first_name, last_name, email, phone_number, hire_date
      FROM employees
      WHERE rownum < 10)
  LOOP

    logit(v_local_record.email, 'D');

  END LOOP;
  
END;
/

--if you want similar like FOR LOOP which is SUPER serialized the BULK COLLECT
