BUILT-IN FUNCTIONS
==================

--let us take an example where SQL functions do not worked in PLSQL

select decode('D','A', 'B','C') 
from dual;

--take an example in PLSQL code
decode_in_plsql.sql
begin
  if decode('D','A','B','C') = 'B'
  then
    logit('this is ganesh', 'D');
   end if;
end; 

decode_in_plsql.sql

we can write in different value
declare
   v_declare_value varchar2(1);
begin
  select decode('D','D','B','C')
   into v_declare_value
   from dual;
   
   if v_declare_value='C'
   then
      logit('this is ganesh','D');
   end if;
end;

--we can still use in the CASE search
BEGIN
    CASE
	WHEN 'D'= 'A'
	THEN
	  LOGIT('this is ganesh','D');
	ELSE
	  null;
	END CASE;
END;

SUBSTR
======
 it give try to search for the position where it starts and return the with the number of characters specified
substr.sql

begin
  dbms_output.put_line(substr('this is ganesh',2,5));
end;

INSTR
======
its return the poistion number when it is searched.

instr.sql

begin
  dbms_output.put_line(instr('this is ganesh','gan'));
end;

--you can also get the get the positions where that occurence , and return the next ocuurence positions.
begin
  dbms_output.put_line(instr('this is ganesh','h',1,2));
end;

--you can also get the backward reference
begin
  dbms_output.put_line(instr('this is ganesh','h',-1,2));
end;


==builtins_as_expressions

builtins_as_expressions.sql
DECLARE
  TYPE r_info IS RECORD (
    loc NUMBER,
    prior_letter VARCHAR2(1) );
    
  TYPE t_info IS TABLE OF r_info
    INDEX BY BINARY_INTEGER;
    
  v_info t_info;
  
  v_string CONSTANT VARCHAR2(30) := 'Ganesh Babu';
BEGIN

  FOR i IN 1..3
  LOOP
    v_info(i).loc := instr(v_string, 'n', 1, i);
    v_info(i).prior_letter := substr(v_string, 
                           v_info(i).loc - 1,
                           1 );
  END LOOP;

  FOR i IN 1..3
  LOOP
    dbms_output.put_line('The letter just before position ' ||
       to_char(v_info(i).loc) || 
       ' is ' ||
       v_info(i).prior_letter  );
  END LOOP;
END;
/

