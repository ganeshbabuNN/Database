CONSTRUCTORS
=============

As discussing A record type is just a data struture where all the attributes comprises into a unit where as in object is contains multiples field i,e attributes but the diff is in the field we can include code with it as i said before object type is a combinations of package and complex types.
-- the record data struture and package strutues will be used in various situationsin PLSQL
-- by default the this type, default construtors. this is done by the oracle
--the sample code like like this.
emp_obj2.sql

CREATE OR REPLACE TYPE emp_obj
AS OBJECT 
(
  last_name VARCHAR2(25),
  first_name VARCHAR2(20),
  email VARCHAR2(25),
  phone_number VARCHAR2(20),
  hire_date DATE,
  salary NUMBER(8,2),
  --- the below code is placed by the oracle by default, no need to put expliclity . the attribute of the object type , to be ----same as the construtor attributes.
  CONSTRUCTOR FUNCTION emp_obj(
    last_name IN VARCHAR2,
    first_name IN VARCHAR2,
    email IN VARCHAR2,
    phone_number IN VARCHAR2,
    hire_date IN DATE,
    salary IN NUMBER )      
    RETURN SELF AS RESULT--- result which in turns return the instance of that actual objects..
)  
NOT FINAL;-- this keyword which is used to reuse in different type across the various create
/


-- like how you have package body and the spec, here also object body can be return for the code.
emp_obj2.sql

'SELF' this is trying to assigning the body to the instance of the object
create or replace
TYPE BODY emp_obj
AS 
  --- this is the specification code
  CONSTRUCTOR FUNCTION emp_obj(
    last_name IN VARCHAR2,
    first_name IN VARCHAR2,
    email IN VARCHAR2,
    phone_number IN VARCHAR2,
    hire_date IN DATE,
    salary IN NUMBER )      
    RETURN SELF AS RESULT
  IS
  --- this is the actual code which is the code 

  BEGIN
    SELF.last_name := last_name;
    SELF.first_name := first_name;
    SELF.email := email;
    SELF.phone_number := phone_number;
    SELF.hire_date := hire_Date;
    SELF.salary := salary;
    
    RETURN;
  END;
END;

---let us call the object that is is emp_obj
DECLARE  
  v_emp_obj emp_obj;
BEGIN

  v_emp_obj := emp_obj(
    last_name => 'ganesh',
    first_name => 'babu',
    email => 'ganesh@g.com',
    phone_number => 'ga',
    hire_date => sysdate,
    salary => 32323);  
END;  
/

---Now creating the construtor , passing without any attribute and with only one attribule
emp_obj3.sql.
CREATE OR REPLACE TYPE emp_obj
AS OBJECT 
(
  last_name VARCHAR2(25),
  first_name VARCHAR2(20),
  email VARCHAR2(25),
  phone_number VARCHAR2(20),
  hire_date DATE,
  salary NUMBER(8,2),
  
  CONSTRUCTOR FUNCTION emp_obj
    RETURN SELF AS RESULT,
    
  CONSTRUCTOR FUNCTION emp_obj(
    email IN VARCHAR2 )      
    RETURN SELF AS RESULT
)  
NOT FINAL 
/

---adding the implementation for the body of above type
emp_obj3.sql
create or replace
TYPE BODY emp_obj
AS 

  CONSTRUCTOR FUNCTION emp_obj
    RETURN SELF AS RESULT
  IS
  BEGIN
    RETURN;
  END;  
  
  CONSTRUCTOR FUNCTION emp_obj(
    email IN VARCHAR2 )      
    RETURN SELF AS RESULT
  IS
  BEGIN
    SELF.email := email;
    
    RETURN;
  END;
END;
/

---same you can even put some initializing value into the empty constructor.
create or replace
TYPE BODY emp_obj
AS 

  CONSTRUCTOR FUNCTION emp_obj
    RETURN SELF AS RESULT
  IS
  BEGIN
    SELF.salary := 0;
    RETURN;
  END;  
  
  CONSTRUCTOR FUNCTION emp_obj(
    email IN VARCHAR2 )      
    RETURN SELF AS RESULT
  IS
  BEGIN
    SELF.email := email;
    
    RETURN;
  END;
END;
/

---now call the object, by default other attributes are called with that constructure, which is called by the constructors.
DECLARE  
  v_emp_obj emp_obj;
BEGIN

  v_emp_obj := emp_obj(); -- you called empty also

  v_emp_obj := emp_obj( -- with one arguments also
    email => 'ganesh@gmail.com' );
  
  v_emp_obj := emp_obj(
    last_name => 'ga',
    first_name => 'bab',
    email => 'gag@ba.cpm',
    phone_number => '3423423423',
    hire_date => sysdate,
    salary => 2333);
  
END; 
/

